{"version":3,"file":"mini-react.mjs","sources":["../src/constant/index.ts","../src/reconciler/reconciler.ts","../src/fiber/fiber.ts","../src/renderer/renderer.ts","../src/renderer/createElement.ts","../src/index.ts"],"sourcesContent":["export enum EFFECT_TAG {\n  /** 更新节点 */\n  UPDATE = 'UPDATE',\n\n  /** 插入节点 */\n  PLACEMENT = 'PLACEMENT',\n\n  /** 删除节点 */\n  DELETION = 'DELETION',\n\n  /** 插入和更新节点 */\n  PLACEMENT_AND_UPDATE = 'PLACEMENT_AND_UPDATE',\n\n  /** 内容重置 */\n  CONTENT_RESET = 'CONTENT_RESET',\n}\n\nexport enum ELEMENT_TYPE {\n  /** 文本节点 */\n  TEXT_ELEMENT = 'TEXT_ELEMENT',\n}\n","import { EFFECT_TAG } from '@/constant/index';\nimport { deleteFiber } from '@/fiber/fiber';\nimport type { Fiber, ReactElement } from '@/types/fiber';\n\n/**\n * reconcile 阶段是在 render 阶段之后进行\n * 主要负责比较新旧两棵树（即新旧虚拟 DOM），并计算出实际的 DOM 更新\n * 这个阶段会标记出哪些节点需要被添加、删除或更新。\n * React 会在这个阶段为每个需要更新的节点打上相应的 EFFECT_TAG，然后在提交阶段（Commit 阶段）统一处理这些更新。\n * @param workInProgress Work in progress fiber\n * @param elements Elements to be reconciled\n */\nexport function reconcileChildren(workInProgress: Fiber, elements: ReactElement[]) {\n  let index = 0;\n  let oldFiber = workInProgress.alternate?.child;\n  let prevSibling: Fiber;\n\n  while (index < elements.length || oldFiber) {\n    const element = elements[index];\n    let newFiber: Fiber;\n\n    const sameType = element?.type === oldFiber?.type;\n\n    /** 相同节点 update */\n    if (sameType) {\n      newFiber = {\n        type: oldFiber?.type,\n        props: element.props,\n        stateNode: oldFiber?.stateNode,\n        return: workInProgress,\n        alternate: oldFiber!,\n        effectTag: EFFECT_TAG.UPDATE,\n        element,\n      };\n    }\n\n    /** 新节点 */\n    if (element && !sameType) {\n      newFiber = {\n        type: element.type,\n        props: element.props,\n        stateNode: undefined,\n        return: workInProgress,\n        alternate: undefined,\n        effectTag: EFFECT_TAG.PLACEMENT,\n        element,\n      };\n    }\n\n    /** 旧节点 删除旧节点 */\n    if (oldFiber && !sameType) {\n      oldFiber.effectTag = EFFECT_TAG.DELETION;\n\n      // TODO: 循环引用\n      deleteFiber(oldFiber);\n    }\n\n    if (oldFiber) {\n      oldFiber = oldFiber.sibling;\n    }\n\n    if (index === 0) {\n      workInProgress.child = newFiber!;\n    } else if (element) {\n      prevSibling!.sibling = newFiber!;\n    }\n\n    prevSibling = newFiber!;\n    index++;\n  }\n}\n","import { EFFECT_TAG, ELEMENT_TYPE } from '@/constant/index';\nimport { reconcileChildren } from '@/reconciler/reconciler';\nimport { createDom, updateDom } from '@/renderer/renderer';\nimport type { Fiber, ReactElement } from '@/types/fiber';\n\n/** Global variables */\nlet nextUnitOfWork: Fiber | undefined;\n/** 当前工作的 fiber 树  */\nlet workInProgressRoot: Fiber;\n/** 上一次渲染的 fiber 树 */\nlet currentRoot: Fiber;\nlet currentFunctionFiber: Fiber | null = null;\n/**  当前正在执行的函数组件对应 fiber */\nlet stateHookIndex = null;\n/** 要执行删除 dom 的 fiber */\nlet deletions: Fiber[] = [];\n\n/** 将某个 fiber 加入 deletions 数组 */\nexport function deleteFiber(fiber: Fiber) {\n  deletions.push(fiber);\n}\n\n/** 获取 deletions 数组 */\nexport function getDeletions() {\n  return deletions;\n}\n\nexport function createRoot(element: ReactElement, container: HTMLElement) {\n  workInProgressRoot = {\n    stateNode: container,\n    props: {\n      children: [element], // 此时的element还只是React.createElement函数创建的virtual dom树\n    },\n    alternate: currentRoot,\n    // element: element,\n  };\n  deletions = [];\n  nextUnitOfWork = workInProgressRoot;\n}\n\nfunction commitWork(fiber?: Fiber) {\n  if (!fiber) {\n    return;\n  }\n\n  let parentDom = fiber?.return?.stateNode!;\n\n  if (fiber.effectTag === EFFECT_TAG.DELETION) {\n    if (fiber.type instanceof Function) {\n      parentDom?.removeChild(fiber.stateNode!);\n    }\n    return;\n  }\n\n  /** 深度优先遍历，先遍历child， 后遍历 sibling */\n  commitWork(fiber.child);\n\n  if (fiber.effectTag === EFFECT_TAG.PLACEMENT) {\n    // 如果有 index 则说明是插入到某个位置，否则是追加到最后\n    const targetPositionDom = parentDom?.childNodes[fiber.index!]; // 要插入到那个 dom 之前\n\n    if (targetPositionDom) {\n      parentDom.insertBefore(fiber.stateNode!, targetPositionDom);\n    } else {\n      parentDom.appendChild(fiber.stateNode!);\n    }\n  } else if (fiber.effectTag === EFFECT_TAG.UPDATE) {\n    // @ TODO:\n    const { children, ...newAttributes } = fiber.element.props;\n    const oldAttributes = Object.assign({}, fiber?.alternate?.element.props);\n    updateDom(fiber.stateNode!, newAttributes, oldAttributes);\n  }\n\n  commitWork(fiber.sibling);\n}\n\nfunction commitRoot() {\n  // deletions.forEach();\n}\n\nfunction updateFunctionComponent(fiber: Fiber) {\n  currentFunctionFiber = fiber;\n  stateHookIndex = 0;\n  currentFunctionFiber.stateHooks = [];\n  currentFunctionFiber.effectHooks = [];\n\n  const children = [fiber.type(fiber.props)];\n  reconcileChildren(fiber, children);\n}\n\nfunction updateHostComponent(fiber: Fiber) {\n  if (!fiber.stateNode) {\n    fiber.stateNode = createDom(fiber);\n  }\n  reconcileChildren(fiber, fiber.props.children);\n}\n\n/**\n * 处理每个 fiber 节点之后，会按照 child、sibling、return 的顺序返回下一个要处理的 fiber 节点：\n */\nfunction performUnitOfWork(fiber: Fiber) {\n  const isFunctionComponent = fiber.type instanceof Function;\n\n  if (isFunctionComponent) {\n    // 如果是函数组件，则需要调用该组件，并将其返回的 JSX 元素转换为 fiber 节点\n    updateFunctionComponent(fiber);\n  } else {\n    // 如果是普通节点，则直接更新该节点\n    updateHostComponent(fiber);\n  }\n\n  if (fiber.child) {\n    return fiber.child;\n  }\n\n  let nextFiber: Fiber | null | undefined = fiber;\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling;\n    }\n    nextFiber = nextFiber.return;\n  }\n}\n\nfunction workLoop(deadline: IdleDeadline) {\n  let shouldYield = false;\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    shouldYield = deadline.timeRemaining() < 1;\n\n    console.log('workInProgressRoot', workInProgressRoot);\n    console.log('currentRoot', currentRoot);\n  }\n\n  if (!nextUnitOfWork && currentFunctionFiber) {\n    commitRoot();\n  }\n\n  requestIdleCallback(workLoop);\n}\n\nrequestIdleCallback(workLoop);\n","import { createRoot } from '@/fiber/fiber';\nimport type { Fiber, ReactElement } from '@/types/fiber';\n\nconst isEvent = (key: string) => key.startsWith('on');\nconst isProperty = (key: string) => key !== 'children';\nconst isNew = (prev: Record<string, any>, next: Record<string, any>) => (key: string) => prev[key] !== next[key];\nconst isGone = (prev: Record<string, any>, next: Record<string, any>) => (key: string) => !(key in next);\n\n/** 根据Fiber节点创建真实DOM */\nexport function createDom(fiber: Fiber) {\n  const dom = fiber.type === 'TEXT_ELEMENT' ? document.createTextNode('') : document.createElement(fiber.type);\n  updateDom(dom, {}, fiber.props);\n  return dom;\n}\n\nexport function updateDom(dom: HTMLElement, prevProps: Record<string, any>, nextProps: Record<string, any>) {\n  Object.keys(prevProps).forEach((key) => {\n    /** remove old events */\n    if (isEvent(key) && (!(key in nextProps) || isNew(prevProps, nextProps)(key))) {\n      const eventType = key.toLowerCase().substring(2);\n      dom.removeEventListener(eventType, prevProps[key]);\n    }\n\n    /** remove old properties */\n    if (isProperty(key) && isGone(prevProps, nextProps)(key)) {\n      // @ts-ignore\n      dom[key] = '';\n    }\n\n    /** update new events */\n    if (isEvent(key) && isNew(prevProps, nextProps)(key)) {\n      const eventType = key.toLowerCase().substring(2);\n      dom.addEventListener(eventType, nextProps[key]);\n    }\n\n    /** update new properties */\n    if (isProperty(key) && isNew(prevProps, nextProps)(key)) {\n      // @ts-ignore\n      dom[key] = nextProps[key];\n    }\n  });\n}\n\n/**\n * render函数主要逻辑：\n * 1. 根据root container容器创建root fiber节点\n * 2. 将nextUnitOfWork指向root fiber节点\n * @param element react element tree\n * @param container root container\n */\nexport function render(element: ReactElement, container: HTMLElement) {\n  createRoot(element, container);\n}\n","import { ELEMENT_TYPE } from '@/constant';\nimport type { ReactElement } from '@/types/fiber';\n/**\n * 文本节点是没有 type、children、props 的, 所以需要单独处理\n * @param text\n * @returns\n */\nfunction createTextElement(text: string): ReactElement {\n  return {\n    type: ELEMENT_TYPE.TEXT_ELEMENT,\n    props: {\n      nodeValue: text,\n      children: [],\n    },\n  };\n}\n\nexport function createElement(type: ELEMENT_TYPE, props: object, ...childrens: ReactElement[]): ReactElement {\n  return {\n    type,\n    props: {\n      ...props,\n      children: childrens.map((child) => {\n        if (typeof child === 'object' && child !== null) {\n          return child;\n        }\n        return createTextElement(child);\n      }),\n    },\n  };\n}\n","import { render } from './renderer/renderer';\nimport { createElement } from './renderer/createElement';\n\nexport { render, createElement };\n\nexport default {\n  render,\n  createElement,\n};\n"],"names":["EFFECT_TAG","ELEMENT_TYPE","reconcileChildren","workInProgress","elements","_a","index","oldFiber","prevSibling","element","newFiber","sameType","deleteFiber","nextUnitOfWork","workInProgressRoot","currentRoot","currentFunctionFiber","deletions","fiber","createRoot","container","updateFunctionComponent","children","updateHostComponent","createDom","performUnitOfWork","nextFiber","workLoop","deadline","shouldYield","isEvent","key","isProperty","isNew","prev","next","isGone","dom","updateDom","prevProps","nextProps","eventType","render","createTextElement","text","createElement","type","props","childrens","child"],"mappings":"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"}