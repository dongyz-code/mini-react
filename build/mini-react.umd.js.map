{"version":3,"file":"mini-react.umd.js","sources":["../src/constant/index.ts","../src/reconciler/reconciler.ts","../src/fiber/fiber.ts","../src/renderer/renderer.ts","../src/renderer/createElement.ts","../src/index.ts"],"sourcesContent":["export enum EFFECT_TAG {\n  /** 更新节点 */\n  UPDATE = 'UPDATE',\n\n  /** 插入节点 */\n  PLACEMENT = 'PLACEMENT',\n\n  /** 删除节点 */\n  DELETION = 'DELETION',\n\n  /** 插入和更新节点 */\n  PLACEMENT_AND_UPDATE = 'PLACEMENT_AND_UPDATE',\n\n  /** 内容重置 */\n  CONTENT_RESET = 'CONTENT_RESET',\n}\n\nexport enum ELEMENT_TYPE {\n  /** 文本节点 */\n  TEXT_ELEMENT = 'TEXT_ELEMENT',\n}\n","import { EFFECT_TAG } from '@/constant/index';\nimport { deleteFiber } from '@/fiber/fiber';\nimport type { Fiber, ReactElement } from '@/types/fiber';\n\n/**\n * reconcile 阶段是在 render 阶段之后进行\n * 主要负责比较新旧两棵树（即新旧虚拟 DOM），并计算出实际的 DOM 更新\n * 这个阶段会标记出哪些节点需要被添加、删除或更新。\n * React 会在这个阶段为每个需要更新的节点打上相应的 EFFECT_TAG，然后在提交阶段（Commit 阶段）统一处理这些更新。\n * @param workInProgress Work in progress fiber\n * @param elements Elements to be reconciled\n */\nexport function reconcileChildren(workInProgress: Fiber, elements: ReactElement[]) {\n  let index = 0;\n  let oldFiber = workInProgress.alternate?.child;\n  let prevSibling: Fiber;\n\n  while (index < elements.length || oldFiber) {\n    const element = elements[index];\n    let newFiber: Fiber;\n\n    const sameType = element?.type === oldFiber?.type;\n\n    /** 相同节点 update */\n    if (sameType) {\n      newFiber = {\n        type: oldFiber?.type,\n        props: element.props,\n        stateNode: oldFiber?.stateNode,\n        return: workInProgress,\n        alternate: oldFiber!,\n        effectTag: EFFECT_TAG.UPDATE,\n        element,\n      };\n    }\n\n    /** 新节点 */\n    if (element && !sameType) {\n      newFiber = {\n        type: element.type,\n        props: element.props,\n        stateNode: undefined,\n        return: workInProgress,\n        alternate: undefined,\n        effectTag: EFFECT_TAG.PLACEMENT,\n        element,\n      };\n    }\n\n    /** 旧节点 删除旧节点 */\n    if (oldFiber && !sameType) {\n      oldFiber.effectTag = EFFECT_TAG.DELETION;\n\n      // TODO: 循环引用\n      deleteFiber(oldFiber);\n    }\n\n    if (oldFiber) {\n      oldFiber = oldFiber.sibling;\n    }\n\n    if (index === 0) {\n      workInProgress.child = newFiber!;\n    } else if (element) {\n      prevSibling!.sibling = newFiber!;\n    }\n\n    prevSibling = newFiber!;\n    index++;\n  }\n}\n","import { EFFECT_TAG, ELEMENT_TYPE } from '@/constant/index';\nimport { reconcileChildren } from '@/reconciler/reconciler';\nimport { createDom, updateDom } from '@/renderer/renderer';\nimport type { Fiber, ReactElement } from '@/types/fiber';\n\n/** Global variables */\nlet nextUnitOfWork: Fiber | undefined;\n/** 当前工作的 fiber 树  */\nlet workInProgressRoot: Fiber;\n/** 上一次渲染的 fiber 树 */\nlet currentRoot: Fiber;\nlet currentFunctionFiber: Fiber | null = null;\n/**  当前正在执行的函数组件对应 fiber */\nlet stateHookIndex = null;\n/** 要执行删除 dom 的 fiber */\nlet deletions: Fiber[] = [];\n\n/** 将某个 fiber 加入 deletions 数组 */\nexport function deleteFiber(fiber: Fiber) {\n  deletions.push(fiber);\n}\n\n/** 获取 deletions 数组 */\nexport function getDeletions() {\n  return deletions;\n}\n\nexport function createRoot(element: ReactElement, container: HTMLElement) {\n  workInProgressRoot = {\n    stateNode: container,\n    props: {\n      children: [element], // 此时的element还只是React.createElement函数创建的virtual dom树\n    },\n    alternate: currentRoot,\n    // element: element,\n  };\n  deletions = [];\n  nextUnitOfWork = workInProgressRoot;\n}\n\nfunction commitWork(fiber?: Fiber) {\n  if (!fiber) {\n    return;\n  }\n\n  let parentDom = fiber?.return?.stateNode!;\n\n  if (fiber.effectTag === EFFECT_TAG.DELETION) {\n    if (fiber.type instanceof Function) {\n      parentDom?.removeChild(fiber.stateNode!);\n    }\n    return;\n  }\n\n  /** 深度优先遍历，先遍历child， 后遍历 sibling */\n  commitWork(fiber.child);\n\n  if (fiber.effectTag === EFFECT_TAG.PLACEMENT) {\n    // 如果有 index 则说明是插入到某个位置，否则是追加到最后\n    const targetPositionDom = parentDom?.childNodes[fiber.index!]; // 要插入到那个 dom 之前\n\n    if (targetPositionDom) {\n      parentDom.insertBefore(fiber.stateNode!, targetPositionDom);\n    } else {\n      parentDom.appendChild(fiber.stateNode!);\n    }\n  } else if (fiber.effectTag === EFFECT_TAG.UPDATE) {\n    // @ TODO:\n    const { children, ...newAttributes } = fiber.element.props;\n    const oldAttributes = Object.assign({}, fiber?.alternate?.element.props);\n    updateDom(fiber.stateNode!, newAttributes, oldAttributes);\n  }\n\n  commitWork(fiber.sibling);\n}\n\nfunction commitRoot() {\n  // deletions.forEach();\n}\n\nfunction updateFunctionComponent(fiber: Fiber) {\n  currentFunctionFiber = fiber;\n  stateHookIndex = 0;\n  currentFunctionFiber.stateHooks = [];\n  currentFunctionFiber.effectHooks = [];\n\n  const children = [fiber.type(fiber.props)];\n  reconcileChildren(fiber, children);\n}\n\nfunction updateHostComponent(fiber: Fiber) {\n  if (!fiber.stateNode) {\n    fiber.stateNode = createDom(fiber);\n  }\n  reconcileChildren(fiber, fiber.props.children);\n}\n\n/**\n * 处理每个 fiber 节点之后，会按照 child、sibling、return 的顺序返回下一个要处理的 fiber 节点：\n */\nfunction performUnitOfWork(fiber: Fiber) {\n  const isFunctionComponent = fiber.type instanceof Function;\n\n  if (isFunctionComponent) {\n    // 如果是函数组件，则需要调用该组件，并将其返回的 JSX 元素转换为 fiber 节点\n    updateFunctionComponent(fiber);\n  } else {\n    // 如果是普通节点，则直接更新该节点\n    updateHostComponent(fiber);\n  }\n\n  if (fiber.child) {\n    return fiber.child;\n  }\n\n  let nextFiber: Fiber | null | undefined = fiber;\n  while (nextFiber) {\n    if (nextFiber.sibling) {\n      return nextFiber.sibling;\n    }\n    nextFiber = nextFiber.return;\n  }\n}\n\nfunction workLoop(deadline: IdleDeadline) {\n  let shouldYield = false;\n  while (nextUnitOfWork && !shouldYield) {\n    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);\n    shouldYield = deadline.timeRemaining() < 1;\n\n    console.log('workInProgressRoot', workInProgressRoot);\n    console.log('currentRoot', currentRoot);\n  }\n\n  if (!nextUnitOfWork && currentFunctionFiber) {\n    commitRoot();\n  }\n\n  requestIdleCallback(workLoop);\n}\n\nrequestIdleCallback(workLoop);\n","import { createRoot } from '@/fiber/fiber';\nimport type { Fiber, ReactElement } from '@/types/fiber';\n\nconst isEvent = (key: string) => key.startsWith('on');\nconst isProperty = (key: string) => key !== 'children';\nconst isNew = (prev: Record<string, any>, next: Record<string, any>) => (key: string) => prev[key] !== next[key];\nconst isGone = (prev: Record<string, any>, next: Record<string, any>) => (key: string) => !(key in next);\n\n/** 根据Fiber节点创建真实DOM */\nexport function createDom(fiber: Fiber) {\n  const dom = fiber.type === 'TEXT_ELEMENT' ? document.createTextNode('') : document.createElement(fiber.type);\n  updateDom(dom, {}, fiber.props);\n  return dom;\n}\n\nexport function updateDom(dom: HTMLElement, prevProps: Record<string, any>, nextProps: Record<string, any>) {\n  Object.keys(prevProps).forEach((key) => {\n    /** remove old events */\n    if (isEvent(key) && (!(key in nextProps) || isNew(prevProps, nextProps)(key))) {\n      const eventType = key.toLowerCase().substring(2);\n      dom.removeEventListener(eventType, prevProps[key]);\n    }\n\n    /** remove old properties */\n    if (isProperty(key) && isGone(prevProps, nextProps)(key)) {\n      // @ts-ignore\n      dom[key] = '';\n    }\n\n    /** update new events */\n    if (isEvent(key) && isNew(prevProps, nextProps)(key)) {\n      const eventType = key.toLowerCase().substring(2);\n      dom.addEventListener(eventType, nextProps[key]);\n    }\n\n    /** update new properties */\n    if (isProperty(key) && isNew(prevProps, nextProps)(key)) {\n      // @ts-ignore\n      dom[key] = nextProps[key];\n    }\n  });\n}\n\n/**\n * render函数主要逻辑：\n * 1. 根据root container容器创建root fiber节点\n * 2. 将nextUnitOfWork指向root fiber节点\n * @param element react element tree\n * @param container root container\n */\nexport function render(element: ReactElement, container: HTMLElement) {\n  createRoot(element, container);\n}\n","import { ELEMENT_TYPE } from '@/constant';\nimport type { ReactElement } from '@/types/fiber';\n/**\n * 文本节点是没有 type、children、props 的, 所以需要单独处理\n * @param text\n * @returns\n */\nfunction createTextElement(text: string): ReactElement {\n  return {\n    type: ELEMENT_TYPE.TEXT_ELEMENT,\n    props: {\n      nodeValue: text,\n      children: [],\n    },\n  };\n}\n\nexport function createElement(type: ELEMENT_TYPE, props: object, ...childrens: ReactElement[]): ReactElement {\n  return {\n    type,\n    props: {\n      ...props,\n      children: childrens.map((child) => {\n        if (typeof child === 'object' && child !== null) {\n          return child;\n        }\n        return createTextElement(child);\n      }),\n    },\n  };\n}\n","import { render } from './renderer/renderer';\nimport { createElement } from './renderer/createElement';\n\nexport { render, createElement };\n\nexport default {\n  render,\n  createElement,\n};\n"],"names":["EFFECT_TAG","ELEMENT_TYPE","reconcileChildren","workInProgress","elements","index","oldFiber","_a","prevSibling","element","newFiber","sameType","deleteFiber","nextUnitOfWork","workInProgressRoot","currentRoot","currentFunctionFiber","deletions","fiber","createRoot","container","updateFunctionComponent","children","updateHostComponent","createDom","performUnitOfWork","nextFiber","workLoop","deadline","shouldYield","isEvent","key","isProperty","isNew","prev","next","isGone","dom","updateDom","prevProps","nextProps","eventType","render","createTextElement","text","createElement","type","props","childrens","child"],"mappings":"iOAAY,IAAAA,GAAAA,IAEVA,EAAA,OAAS,SAGTA,EAAA,UAAY,YAGZA,EAAA,SAAW,WAGXA,EAAA,qBAAuB,uBAGvBA,EAAA,cAAgB,gBAdNA,IAAAA,GAAA,CAAA,CAAA,EAiBAC,GAAAA,IAEVA,EAAA,aAAe,eAFLA,IAAAA,GAAA,CAAA,CAAA,ECLI,SAAAC,EAAkBC,EAAuBC,EAA0B,OACjF,IAAIC,EAAQ,EACRC,GAAWC,EAAAJ,EAAe,YAAf,YAAAI,EAA0B,MACrCC,EAEG,KAAAH,EAAQD,EAAS,QAAUE,GAAU,CACpC,MAAAG,EAAUL,EAASC,CAAK,EAC1B,IAAAK,EAEE,MAAAC,GAAWF,GAAA,YAAAA,EAAS,SAASH,GAAA,YAAAA,EAAU,MAGzCK,IACSD,EAAA,CACT,KAAMJ,GAAA,YAAAA,EAAU,KAChB,MAAOG,EAAQ,MACf,UAAWH,GAAA,YAAAA,EAAU,UACrB,OAAQH,EACR,UAAWG,EACX,UAAWN,EAAW,OACtB,QAAAS,CAAA,GAKAA,GAAW,CAACE,IACHD,EAAA,CACT,KAAMD,EAAQ,KACd,MAAOA,EAAQ,MACf,UAAW,OACX,OAAQN,EACR,UAAW,OACX,UAAWH,EAAW,UACtB,QAAAS,CAAA,GAKAH,GAAY,CAACK,IACfL,EAAS,UAAYN,EAAW,SAGhCY,EAAYN,CAAQ,GAGlBA,IACFA,EAAWA,EAAS,SAGlBD,IAAU,EACZF,EAAe,MAAQO,EACdD,IACTD,EAAa,QAAUE,GAGXF,EAAAE,EACdL,GACF,CACF,CChEA,IAAIQ,EAEAC,EAEAC,EACAC,EAAqC,KAIrCC,EAAqB,CAAA,EAGlB,SAASL,EAAYM,EAAc,CACxCD,EAAU,KAAKC,CAAK,CACtB,CAOgB,SAAAC,EAAWV,EAAuBW,EAAwB,CACnDN,EAAA,CACnB,UAAWM,EACX,MAAO,CACL,SAAU,CAACX,CAAO,CACpB,EACA,UAAWM,CAAA,EAGbE,EAAY,CAAA,EACKJ,EAAAC,CACnB,CA0CA,SAASO,EAAwBH,EAAc,CACtBF,EAAAE,EAEvBF,EAAqB,WAAa,GAClCA,EAAqB,YAAc,GAEnC,MAAMM,EAAW,CAACJ,EAAM,KAAKA,EAAM,KAAK,CAAC,EACzChB,EAAkBgB,EAAOI,CAAQ,CACnC,CAEA,SAASC,EAAoBL,EAAc,CACpCA,EAAM,YACHA,EAAA,UAAYM,EAAUN,CAAK,GAEjBhB,EAAAgB,EAAOA,EAAM,MAAM,QAAQ,CAC/C,CAKA,SAASO,EAAkBP,EAAc,CAWvC,GAV4BA,EAAM,gBAAgB,SAIhDG,EAAwBH,CAAK,EAG7BK,EAAoBL,CAAK,EAGvBA,EAAM,MACR,OAAOA,EAAM,MAGf,IAAIQ,EAAsCR,EAC1C,KAAOQ,GAAW,CAChB,GAAIA,EAAU,QACZ,OAAOA,EAAU,QAEnBA,EAAYA,EAAU,MACxB,CACF,CAEA,SAASC,EAASC,EAAwB,CACxC,IAAIC,EAAc,GACX,KAAAhB,GAAkB,CAACgB,GACxBhB,EAAiBY,EAAkBZ,CAAc,EACnCgB,EAAAD,EAAS,cAAkB,EAAA,EAEjC,QAAA,IAAI,qBAAsBd,CAAkB,EAC5C,QAAA,IAAI,cAAeC,CAAW,EAOxC,oBAAoBY,CAAQ,CAC9B,CAEA,oBAAoBA,CAAQ,EC1I5B,MAAMG,EAAWC,GAAgBA,EAAI,WAAW,IAAI,EAC9CC,EAAcD,GAAgBA,IAAQ,WACtCE,EAAQ,CAACC,EAA2BC,IAA+BJ,GAAgBG,EAAKH,CAAG,IAAMI,EAAKJ,CAAG,EACzGK,EAAS,CAACF,EAA2BC,IAA+BJ,GAAgB,EAAEA,KAAOI,GAG5F,SAASX,EAAUN,EAAc,CAChC,MAAAmB,EAAMnB,EAAM,OAAS,eAAiB,SAAS,eAAe,EAAE,EAAI,SAAS,cAAcA,EAAM,IAAI,EAC3G,OAAAoB,EAAUD,EAAK,CAAA,EAAInB,EAAM,KAAK,EACvBmB,CACT,CAEgB,SAAAC,EAAUD,EAAkBE,EAAgCC,EAAgC,CAC1G,OAAO,KAAKD,CAAS,EAAE,QAASR,GAAQ,CAElC,GAAAD,EAAQC,CAAG,IAAM,EAAEA,KAAOS,IAAcP,EAAMM,EAAWC,CAAS,EAAET,CAAG,GAAI,CAC7E,MAAMU,EAAYV,EAAI,YAAY,EAAE,UAAU,CAAC,EAC/CM,EAAI,oBAAoBI,EAAWF,EAAUR,CAAG,CAAC,CACnD,CASI,GANAC,EAAWD,CAAG,GAAKK,EAAOG,EAAWC,CAAS,EAAET,CAAG,IAErDM,EAAIN,CAAG,EAAI,IAITD,EAAQC,CAAG,GAAKE,EAAMM,EAAWC,CAAS,EAAET,CAAG,EAAG,CACpD,MAAMU,EAAYV,EAAI,YAAY,EAAE,UAAU,CAAC,EAC/CM,EAAI,iBAAiBI,EAAWD,EAAUT,CAAG,CAAC,CAChD,CAGIC,EAAWD,CAAG,GAAKE,EAAMM,EAAWC,CAAS,EAAET,CAAG,IAEhDM,EAAAN,CAAG,EAAIS,EAAUT,CAAG,EAC1B,CACD,CACH,CASgB,SAAAW,EAAOjC,EAAuBW,EAAwB,CACpED,EAAWV,EAASW,CAAS,CAC/B,CC7CA,SAASuB,EAAkBC,EAA4B,CAC9C,MAAA,CACL,KAAM3C,EAAa,aACnB,MAAO,CACL,UAAW2C,EACX,SAAU,CAAC,CACb,CAAA,CAEJ,CAEgB,SAAAC,EAAcC,EAAoBC,KAAkBC,EAAyC,CACpG,MAAA,CACL,KAAAF,EACA,MAAO,CACL,GAAGC,EACH,SAAUC,EAAU,IAAKC,GACnB,OAAOA,GAAU,UAAYA,IAAU,KAClCA,EAEFN,EAAkBM,CAAK,CAC/B,CACH,CAAA,CAEJ,CCzBe,MAAA5C,EAAA,CACb,OAAAqC,EACA,cAAAG,CACF"}